// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title EventRegistry
 * @notice Stores Hedera ticketing events on-chain so they persist between sessions.
 * Each event is keyed by a string identifier generated by the client. The creator
 * of an event (msg.sender when `createOrUpdateEvent` is called) becomes the owner
 * of that event and is the only account allowed to update its stored values.
 */
contract EventRegistry {
    struct EventData {
        string id;
        string name;
        string description;
        string date;
        uint256 ticketPrice;
        uint256 maxTickets;
        string coverImage;
        string metadataFileId;
        string tokenId;
        address creator;
        string creatorAccountId;
        uint256 createdAt;
        uint256 ticketsSold;
    }

    mapping(bytes32 => EventData) private _eventsByKey;
    bytes32[] private _eventKeys;

    event EventUpserted(string indexed id, address indexed creator, bool isNew);
    event TicketsSoldUpdated(string indexed id, uint256 ticketsSold);

    /**
     * @dev Allows a wallet to create a new event or update an existing one.
     * The caller becomes the event creator and is the only party authorized
     * to make subsequent updates.
     */
    function createOrUpdateEvent(
        string memory id,
        string memory name,
        string memory description,
        string memory date,
        uint256 ticketPrice,
        uint256 maxTickets,
        string memory coverImage,
        string memory metadataFileId,
        string memory tokenId,
        string memory creatorAccountId,
        uint256 ticketsSold
    ) external {
        bytes32 key = keccak256(bytes(id));
        EventData storage stored = _eventsByKey[key];
        bool isNew = bytes(stored.id).length == 0;

        if (!isNew) {
            require(stored.creator == msg.sender, "EVENT_NOT_OWNED");
        }

        stored.id = id;
        stored.name = name;
        stored.description = description;
        stored.date = date;
        stored.ticketPrice = ticketPrice;
        stored.maxTickets = maxTickets;
        stored.coverImage = coverImage;
        stored.metadataFileId = metadataFileId;
        stored.tokenId = tokenId;
        stored.creator = msg.sender;
        stored.creatorAccountId = creatorAccountId;
        stored.ticketsSold = ticketsSold;

        if (isNew) {
            stored.createdAt = block.timestamp;
            _eventKeys.push(key);
        }

        emit EventUpserted(id, msg.sender, isNew);
    }

    /**
     * @dev Updates ticket sales counter for an event. This is restricted to the creator.
     */
    function updateTicketsSold(string memory id, uint256 ticketsSold) external {
        bytes32 key = keccak256(bytes(id));
        EventData storage stored = _eventsByKey[key];
        require(bytes(stored.id).length != 0, "EVENT_NOT_FOUND");
        require(stored.creator == msg.sender, "EVENT_NOT_OWNED");

        stored.ticketsSold = ticketsSold;
        emit TicketsSoldUpdated(id, ticketsSold);
    }

    /**
     * @dev Returns the event data for a given identifier.
     */
    function getEvent(string memory id) external view returns (EventData memory) {
        bytes32 key = keccak256(bytes(id));
        EventData memory stored = _eventsByKey[key];
        require(bytes(stored.id).length != 0, "EVENT_NOT_FOUND");
        return stored;
    }

    /**
     * @dev Returns the number of stored events.
     */
    function getEventCount() external view returns (uint256) {
        return _eventKeys.length;
    }

    /**
     * @dev Returns the event data at a particular index.
     */
    function getEventByIndex(uint256 index) external view returns (EventData memory) {
        require(index < _eventKeys.length, "INDEX_OUT_OF_BOUNDS");
        return _eventsByKey[_eventKeys[index]];
    }

    /**
     * @dev Returns every stored event. Intended for off-chain reads.
     */
    function listEvents() external view returns (EventData[] memory) {
        EventData[] memory events = new EventData[](_eventKeys.length);
        for (uint256 i = 0; i < _eventKeys.length; i++) {
            events[i] = _eventsByKey[_eventKeys[i]];
        }
        return events;
    }
}
